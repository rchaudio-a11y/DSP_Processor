Imports System.Diagnostics
Imports System.Threading
Imports System.Collections.Concurrent
Imports DSP_Processor.AudioIO
Imports DSP_Processor.Models

Namespace Recording

    Public Class RecordingEngine

        Public Property InputSource As IInputSource
        Public Property OutputFolder As String = "Recordings"
        Public Property AutoNamePattern As String = "Take_{0:yyyyMMdd}-{1:000}.wav"

        ' NEW: Recording options
        Public Property Options As RecordingOptions = New RecordingOptions()

        ' Legacy properties (kept for compatibility, but Options takes precedence)
        <Obsolete("Use Options.Mode instead")>
        Public Property TimedRecordingEnabled As Boolean = False
        <Obsolete("Use Options.TimedDurationSeconds instead")>
        Public Property RecordingDurationSeconds As Integer = 30
        <Obsolete("Use Options.LoopCount instead")>
        Public Property AutoRestartEnabled As Boolean = False
        <Obsolete("Use Options.LoopCount instead")>
        Public Property MaxRecordings As Integer = 1

        Private wavOut As WavFileOutput
        Private stopwatch As Stopwatch
        Private currentIndex As Integer = 1
        Private recordingActive As Boolean = False
        Private lastProcessedBuffer As Byte() = Nothing
        
        ' NEW: Loop mode state
        Private loopCurrentTake As Integer = 0
        Private loopDelayTimer As Stopwatch
        Private isInLoopDelay As Boolean = False

        ' ASYNC FILE WRITING: Background writer thread + lock-free queue
        Private ReadOnly _writeQueue As New ConcurrentQueue(Of Byte())
        Private _writerThread As Thread
        Private _writerRunning As Boolean = False
        Private ReadOnly _writerStopwatch As New Stopwatch()
        Private _totalWriteTimeMs As Double = 0
        Private _writeCount As Long = 0
        Private _queueOverflows As Long = 0
        Private Const MaxQueueDepth As Integer = 100  ' Prevent memory overflow

        ''' <summary>
        ''' Gets the last processed audio buffer for level metering
        ''' </summary>
        Public ReadOnly Property LastBuffer As Byte()
            Get
                Return lastProcessedBuffer
            End Get
        End Property

        ''' <summary>
        ''' Gets whether recording is currently active
        ''' </summary>
        Public ReadOnly Property IsRecording As Boolean
            Get
                Return recordingActive
            End Get
        End Property

        ''' <summary>
        ''' Gets the current recording duration
        ''' </summary>
        Public ReadOnly Property RecordingDuration As TimeSpan
            Get
                If recordingActive AndAlso stopwatch IsNot Nothing Then
                    Return stopwatch.Elapsed
                End If
                Return TimeSpan.Zero
            End Get
        End Property

        Public Sub StartRecording()
            If Not IO.Directory.Exists(OutputFolder) Then
                IO.Directory.CreateDirectory(OutputFolder)
            End If

            ' Generate filename with date and auto-incrementing index
            Dim today = DateTime.Now
            Dim dateStr = today.ToString("yyyyMMdd")
            Dim fullPath As String
            Dim index As Integer = 1

            ' Find next available index for today's date
            Do
                Dim filename = String.Format(AutoNamePattern, today, index)
                fullPath = IO.Path.Combine(OutputFolder, filename)

                If Not IO.File.Exists(fullPath) Then
                    Exit Do
                End If

                index += 1
            Loop While index < 1000 ' Safety limit

            ' Ensure file is not locked by releasing any handles
            GC.Collect()
            GC.WaitForPendingFinalizers()

            ' Create WAV file
            wavOut = New WavFileOutput(fullPath, InputSource.SampleRate, InputSource.Channels, InputSource.BitsPerSample)

            ' ASYNC: Start background writer thread
            StartWriterThread()

            stopwatch = Stopwatch.StartNew()
            recordingActive = True

            ' Immediately flush initial audio buffers in a tight loop
            ' Process 10 times with minimal delay to capture startup audio
            For i = 1 To 10
                Process()
            Next
        End Sub

        Public Sub StopRecording()
            recordingActive = False
            stopwatch?.Stop()

            ' ASYNC: Stop background writer thread (flushes remaining buffers)
            StopWriterThread()

            Try
                If wavOut IsNot Nothing Then
                    wavOut.Dispose() ' Use Dispose instead of CloseSink
                    wavOut = Nothing
                End If
            Catch ex As Exception
                ' Log error if logger is available
                Try
                    Utils.Logger.Instance.Error("Failed to close recording file", ex, "RecordingEngine")
                Catch
                    ' Logger might not be initialized
                End Try
            End Try

            ' Log async write stats
            If _writeCount > 0 Then
                Dim avgTime = _totalWriteTimeMs / _writeCount
                Utils.Logger.Instance.Info($"Async Write Stats: {_writeCount} buffers, Avg={avgTime:F3}ms, Overflows={_queueOverflows}", "RecordingEngine")
            End If

            currentIndex += 1

            ' Legacy auto-restart (deprecated, use Options.Mode = LoopMode instead)
            If AutoRestartEnabled AndAlso currentIndex <= MaxRecordings Then
                StartRecording()
            End If
        End Sub
        
        ''' <summary>
        ''' Start a loop recording session
        ''' </summary>
        Public Sub StartLoopRecording()
            If Options.Mode <> RecordingMode.LoopMode Then
                Throw New InvalidOperationException("StartLoopRecording requires Options.Mode = LoopMode")
            End If
            
            loopCurrentTake = 1
            isInLoopDelay = False
            Utils.Logger.Instance.Info($"Starting loop recording: {Options.LoopCount} takes × {Options.LoopDurationSeconds}s", "RecordingEngine")
            Services.LoggingServiceAdapter.Instance.LogInfo($"Loop mode: {Options.LoopCount} takes × {Options.LoopDurationSeconds}s")
            StartRecording()
        End Sub
        
        ''' <summary>
        ''' Cancel loop recording (stop all remaining takes)
        ''' </summary>
        Public Sub CancelLoopRecording()
            If Options.Mode = RecordingMode.LoopMode Then
                loopCurrentTake = Options.LoopCount ' Force loop to end
                isInLoopDelay = False
            End If
            StopRecording()
        End Sub

        Public Sub Process()
            If Not recordingActive Then
                ' Check if we're in loop delay
                If isInLoopDelay AndAlso loopDelayTimer IsNot Nothing Then
                    If loopDelayTimer.Elapsed.TotalSeconds >= Options.LoopDelaySeconds Then
                        ' Delay complete, start next take
                        isInLoopDelay = False
                        loopCurrentTake += 1
                        
                        If loopCurrentTake <= Options.LoopCount Then
                            Utils.Logger.Instance.Info($"Starting loop take {loopCurrentTake} of {Options.LoopCount}", "RecordingEngine")
                            Services.LoggingServiceAdapter.Instance.LogInfo($"Starting take {loopCurrentTake}/{Options.LoopCount}")
                            StartRecording()
                        Else
                            ' Loop complete
                            Utils.Logger.Instance.Info("Loop recording complete", "RecordingEngine")
                            Services.LoggingServiceAdapter.Instance.LogInfo($"Loop recording complete: {Options.LoopCount} takes finished")
                            loopCurrentTake = 0
                        End If
                    End If
                End If
                Exit Sub
            End If

            ' Keep buffer small (4KB) for responsive FFT/metering
            Dim buffer(4095) As Byte
            Dim read = InputSource.Read(buffer, 0, buffer.Length)

            If read > 0 Then
                ' ASYNC: Enqueue buffer for background writing (FAST! No disk I/O on this thread!)
                If _writeQueue.Count < MaxQueueDepth Then
                    ' Copy only valid data
                    Dim writeBuffer(read - 1) As Byte
                    Array.Copy(buffer, writeBuffer, read)
                    _writeQueue.Enqueue(writeBuffer)
                Else
                    ' Queue full - log overflow (this means disk can't keep up!)
                    Interlocked.Increment(_queueOverflows)
                    Utils.Logger.Instance.Warning($"Write queue overflow! Depth={_writeQueue.Count}, dropping buffer", "RecordingEngine")
                End If

                ' Store buffer for metering (keep this synchronous for UI)
                If read = buffer.Length Then
                    lastProcessedBuffer = buffer
                Else
                    ' Partial buffer - copy only valid data
                    ReDim lastProcessedBuffer(read - 1)
                    Array.Copy(buffer, lastProcessedBuffer, read)
                End If
            Else
                ' No data available - log occasionally at debug level (this is normal)
                Static lastLogTime As DateTime = DateTime.MinValue
                If DateTime.Now.Subtract(lastLogTime).TotalSeconds > 5 Then
                    Utils.Logger.Instance.Debug("Buffer queue temporarily empty (normal during recording)", "RecordingEngine")
                    lastLogTime = DateTime.Now
                End If
            End If

            ' Check auto-stop conditions based on mode
            Select Case Options.Mode
                Case RecordingMode.Manual
                    ' No auto-stop, user must stop manually
                    
                Case RecordingMode.Timed
                    ' Stop after specified duration
                    If stopwatch.Elapsed.TotalSeconds >= Options.TimedDurationSeconds Then
                        Utils.Logger.Instance.Info($"Timed recording complete: {stopwatch.Elapsed.TotalSeconds:F1}s", "RecordingEngine")
                        Services.LoggingServiceAdapter.Instance.LogInfo($"Timed recording complete ({Options.TimedDurationSeconds}s)")
                        StopRecording()
                    End If
                    
                Case RecordingMode.LoopMode
                    ' Stop after each take duration, then start delay
                    If stopwatch.Elapsed.TotalSeconds >= Options.LoopDurationSeconds Then
                        Utils.Logger.Instance.Info($"Loop take {loopCurrentTake} complete: {stopwatch.Elapsed.TotalSeconds:F1}s", "RecordingEngine")
                        Services.LoggingServiceAdapter.Instance.LogInfo($"Take {loopCurrentTake} complete ({Options.LoopDurationSeconds}s)")
                        StopRecording()
                        
                        ' Give file system time to fully close the file
                        System.Threading.Thread.Sleep(100)
                        
                        If loopCurrentTake < Options.LoopCount Then
                            ' Start delay before next take
                            isInLoopDelay = True
                            loopDelayTimer = Stopwatch.StartNew()
                            Services.LoggingServiceAdapter.Instance.LogInfo($"Waiting {Options.LoopDelaySeconds}s before next take...")
                        Else
                            ' All takes complete
                            loopCurrentTake = 0
                            Utils.Logger.Instance.Info("All loop takes complete", "RecordingEngine")
                        End If
                    End If
            End Select
        End Sub

        ''' <summary>
        ''' Background writer thread loop - ASYNC FILE WRITING
        ''' Runs independently from audio thread, writes buffers to disk
        ''' </summary>
        Private Sub WriterThreadLoop()
            Utils.Logger.Instance.Info("Background writer thread started", "RecordingEngine")
            
            While _writerRunning
                Try
                    Dim writeBuffer As Byte() = Nothing
                    
                    ' Try to dequeue a buffer (non-blocking)
                    If _writeQueue.TryDequeue(writeBuffer) Then
                        If writeBuffer IsNot Nothing AndAlso wavOut IsNot Nothing Then
                            ' TIME the write operation
                            _writerStopwatch.Restart()
                            
                            ' Write to disk (on background thread, doesn't block audio!)
                            wavOut.Write(writeBuffer, writeBuffer.Length)
                            
                            _writerStopwatch.Stop()
                            Dim elapsed = _writerStopwatch.Elapsed.TotalMilliseconds
                            _totalWriteTimeMs += elapsed
                            Interlocked.Increment(_writeCount)
                            
                            ' Log slow writes (> 10ms on background thread is concerning)
                            If elapsed > 10.0 Then
                                Utils.Logger.Instance.Warning($"SLOW disk write: {elapsed:F2}ms (background thread)", "RecordingEngine")
                            End If
                        End If
                    Else
                        ' Queue empty, sleep briefly to avoid spinning
                        Thread.Sleep(1)
                    End If
                    
                Catch ex As Exception
                    Utils.Logger.Instance.Error("Error in writer thread", ex, "RecordingEngine")
                    ' Don't crash the thread, just log and continue
                End Try
            End While
            
            ' Flush remaining buffers on shutdown
            Utils.Logger.Instance.Info("Writer thread shutting down, flushing remaining buffers...", "RecordingEngine")
            Dim remaining As Integer = 0
            Dim flushBuffer As Byte() = Nothing
            While _writeQueue.TryDequeue(flushBuffer)
                If flushBuffer IsNot Nothing AndAlso wavOut IsNot Nothing Then
                    Try
                        wavOut.Write(flushBuffer, flushBuffer.Length)
                        remaining += 1
                    Catch ex As Exception
                        Utils.Logger.Instance.Error("Error flushing buffer on shutdown", ex, "RecordingEngine")
                    End Try
                End If
            End While
            
            If remaining > 0 Then
                Utils.Logger.Instance.Info($"Flushed {remaining} remaining buffers on shutdown", "RecordingEngine")
            End If
            
            Utils.Logger.Instance.Info("Background writer thread stopped", "RecordingEngine")
        End Sub

        ''' <summary>
        ''' Start the background writer thread
        ''' </summary>
        Private Sub StartWriterThread()
            If _writerThread IsNot Nothing AndAlso _writerThread.IsAlive Then
                Return  ' Already running
            End If
            
            _writerRunning = True
            _writerThread = New Thread(AddressOf WriterThreadLoop) With {
                .Name = "RecordingEngine Writer Thread",
                .IsBackground = True,
                .Priority = ThreadPriority.AboveNormal  ' High priority for disk I/O
            }
            _writerThread.Start()
            
            Utils.Logger.Instance.Info("Background writer thread created and started", "RecordingEngine")
        End Sub

        ''' <summary>
        ''' Stop the background writer thread
        ''' </summary>
        Private Sub StopWriterThread()
            If _writerThread Is Nothing OrElse Not _writerThread.IsAlive Then
                Return  ' Not running
            End If
            
            Utils.Logger.Instance.Info("Stopping background writer thread...", "RecordingEngine")
            _writerRunning = False
            
            ' Wait for thread to finish (with timeout)
            If Not _writerThread.Join(5000) Then
                Utils.Logger.Instance.Warning("Writer thread did not stop within timeout, aborting", "RecordingEngine")
                _writerThread.Abort()
            End If
            
            _writerThread = Nothing
            Utils.Logger.Instance.Info("Background writer thread stopped", "RecordingEngine")
        End Sub

    End Class
End Namespace