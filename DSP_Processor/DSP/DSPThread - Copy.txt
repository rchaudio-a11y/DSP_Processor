Imports System.Threading
Imports NAudio.Wave

Namespace DSP

    ''' <summary>
    ''' Pull-based DSP processing with dedicated worker thread.
    ''' Worker thread keeps output buffer filled ahead of WaveOut.
    ''' WaveOut thread NEVER does DSP work - only reads from output buffer.
    ''' </summary>
    Public Class DSPThread
        Implements IDisposable

#Region "Private Fields"

        Private ReadOnly inputBuffer As Utils.RingBuffer
        Private ReadOnly outputBuffer As Utils.RingBuffer
        Private ReadOnly inputMonitorBuffer As Utils.RingBuffer ' Monitor BEFORE processing (raw audio)
        Private ReadOnly outputMonitorBuffer As Utils.RingBuffer ' Monitor AFTER processing (processed audio)
        Private ReadOnly processorChain As ProcessorChain
        Private ReadOnly workBuffer As AudioBuffer
        Private disposed As Boolean = False
        Private ReadOnly inputLowEvent As AutoResetEvent ' Signal feeder when input low
        
        ' Worker thread for DSP processing
        Private workerThread As Thread
        Private shouldStop As Boolean = False
        Private _isRunning As Boolean = False

        ' Processing stats
        Private _processedSamples As Long = 0
        Private _droppedSamples As Long = 0

#End Region

#Region "Properties"

        ''' <summary>Gets the wave format</summary>
        Public ReadOnly Property Format As WaveFormat

        ''' <summary>Gets the processor chain</summary>
        Public ReadOnly Property Chain As ProcessorChain
            Get
                Return processorChain
            End Get
        End Property

        ''' <summary>Gets whether worker thread is running</summary>
        Public ReadOnly Property IsRunning As Boolean
            Get
                Return _isRunning
            End Get
        End Property

        ''' <summary>Gets the total number of processed samples</summary>
        Public ReadOnly Property ProcessedSamples As Long
            Get
                Return Interlocked.Read(_processedSamples)
            End Get
        End Property

        ''' <summary>Gets the total number of dropped samples (underruns)</summary>
        Public ReadOnly Property DroppedSamples As Long
            Get
                Return Interlocked.Read(_droppedSamples)
            End Get
        End Property

        ''' <summary>Gets the event for signaling file feeder</summary>
        Public ReadOnly Property InputLowSignal As AutoResetEvent
            Get
                Return inputLowEvent
            End Get
        End Property

#End Region

#Region "Constructor"

        ''' <summary>
        ''' Creates a new DSP thread
        ''' </summary>
        ''' <param name="format">Wave format to process</param>
        ''' <param name="inputBufferSize">Input buffer size in bytes</param>
        ''' <param name="outputBufferSize">Output buffer size in bytes</param>
        Public Sub New(format As WaveFormat, inputBufferSize As Integer, outputBufferSize As Integer)
            If format Is Nothing Then
                Throw New ArgumentNullException(NameOf(format))
            End If

            Me.Format = format
            inputLowEvent = New AutoResetEvent(False)

            ' Create buffers
            inputBuffer = New Utils.RingBuffer(inputBufferSize)
            outputBuffer = New Utils.RingBuffer(outputBufferSize)
            
            ' Create monitor buffers (0.5 seconds each for FFT)
            Dim monitorSize = outputBufferSize \ 4
            inputMonitorBuffer = New Utils.RingBuffer(monitorSize)
            outputMonitorBuffer = New Utils.RingBuffer(monitorSize)

            ' Create processor chain
            processorChain = New ProcessorChain(format)

            ' Create work buffer (256 samples)
            Const BLOCK_SIZE_SAMPLES As Integer = 256
            Dim blockSizeBytes = BLOCK_SIZE_SAMPLES * format.BlockAlign
            workBuffer = New AudioBuffer(format, blockSizeBytes, True)
            
            Utils.Logger.Instance.Info($"DSP initialized (pull-based with worker thread): {BLOCK_SIZE_SAMPLES} samples ({blockSizeBytes} bytes, {format.Channels}ch)", "DSPThread")
            Utils.Logger.Instance.Info($"Monitor buffers: {monitorSize} bytes each (0.5 seconds) - Input (raw) + Output (processed)", "DSPThread")
        End Sub

#End Region

#Region "Public Methods"

        ''' <summary>
        ''' Start the DSP worker thread
        ''' </summary>
        Public Sub Start()
            If disposed Then Throw New ObjectDisposedException(NameOf(DSPThread))
            If _isRunning Then Return

            shouldStop = False
            workerThread = New Thread(AddressOf WorkerLoop)
            workerThread.Name = "DSP Worker Thread"
            workerThread.Priority = ThreadPriority.AboveNormal ' High priority for real-time
            workerThread.IsBackground = True
            workerThread.Start()

            Utils.Logger.Instance.Info("DSP worker thread started", "DSPThread")
        End Sub

        ''' <summary>
        ''' Stop the DSP worker thread
        ''' </summary>
        Public Sub [Stop]()
            If Not _isRunning Then Return

            shouldStop = True
            workerThread?.Join(1000) ' Wait up to 1 second

            Utils.Logger.Instance.Info($"DSP worker stopped. Processed: {ProcessedSamples}, Dropped: {DroppedSamples}", "DSPThread")
        End Sub

        ''' <summary>
        ''' Writes audio data to the input buffer
        ''' </summary>
        Public Function WriteInput(data As Byte(), offset As Integer, count As Integer) As Integer
            If disposed Then Throw New ObjectDisposedException(NameOf(DSPThread))
            Return inputBuffer.Write(data, offset, count)
        End Function

        ''' <summary>
        ''' Reads processed audio data from the output buffer (called by WaveOut)
        ''' REAL-TIME SAFE: Never blocks, never does DSP work
        ''' </summary>
        Public Function ReadOutput(data As Byte(), offset As Integer, count As Integer) As Integer
            If disposed Then Throw New ObjectDisposedException(NameOf(DSPThread))
            Return outputBuffer.Read(data, offset, count)
        End Function

        ''' <summary>
        ''' Reads RAW audio from INPUT monitor buffer (before DSP processing)
        ''' NON-BLOCKING: For FFT comparison - shows what went INTO the DSP
        ''' </summary>
        Public Function ReadInputMonitor(data As Byte(), offset As Integer, count As Integer) As Integer
            If disposed Then Throw New ObjectDisposedException(NameOf(DSPThread))
            Return inputMonitorBuffer.Read(data, offset, count)
        End Function

        ''' <summary>
        ''' Reads PROCESSED audio from OUTPUT monitor buffer (after DSP processing)
        ''' NON-BLOCKING: For FFT comparison - shows what came OUT of the DSP
        ''' </summary>
        Public Function ReadOutputMonitor(data As Byte(), offset As Integer, count As Integer) As Integer
            If disposed Then Throw New ObjectDisposedException(NameOf(DSPThread))
            Return outputMonitorBuffer.Read(data, offset, count)
        End Function

        ''' <summary>
        ''' Gets the number of bytes available in the output buffer
        ''' </summary>
        Public Function OutputAvailable() As Integer
            Return outputBuffer.Available
        End Function

        ''' <summary>
        ''' Gets the number of bytes available in the INPUT monitor buffer
        ''' </summary>
        Public Function InputMonitorAvailable() As Integer
            Return inputMonitorBuffer.Available
        End Function

        ''' <summary>
        ''' Gets the number of bytes available in the OUTPUT monitor buffer
        ''' </summary>
        Public Function OutputMonitorAvailable() As Integer
            Return outputMonitorBuffer.Available
        End Function

        ''' <summary>
        ''' Gets the number of bytes available in the input buffer
        ''' </summary>
        Public Function InputAvailable() As Integer
            Return inputBuffer.Available
        End Function

        ''' <summary>
        ''' Clears all buffers
        ''' </summary>
        Public Sub ClearBuffers()
            inputBuffer?.Clear()
            outputBuffer?.Clear()
            workBuffer?.Clear()
        End Sub

        ''' <summary>
        ''' Resets the processor chain
        ''' </summary>
        Public Sub ResetProcessors()
            processorChain?.Reset()
        End Sub

#End Region

#Region "Private Methods"

        ''' <summary>
        ''' DSP worker thread loop - keeps output buffer filled ahead of WaveOut
        ''' Rate-matched to audio playback speed (not unlimited processing)
        ''' </summary>
        Private Sub WorkerLoop()
            _isRunning = True
            Dim cycleCount As Long = 0
            
            ' Calculate target delay to match sample rate
            ' 256 samples at 44.1kHz = 5.8ms per block
            Dim samplesPerBlock As Integer = 256
            Dim targetMsPerBlock As Double = (samplesPerBlock / Format.SampleRate) * 1000.0
            Dim targetTicksPerBlock As Long = CLng(targetMsPerBlock * TimeSpan.TicksPerMillisecond)
            
            Dim stopwatch = Diagnostics.Stopwatch.StartNew()
            Dim nextProcessTime As Long = targetTicksPerBlock

            Try
                While Not shouldStop
                    ' Check if we have enough input data to process
                    If inputBuffer.Available >= workBuffer.Capacity Then
                        ' Check if it's time to process next block (rate limiting)
                        Dim currentTime = stopwatch.ElapsedTicks
                        If currentTime >= nextProcessTime Then
                            ' Process one block
                            Dim bytesRead = inputBuffer.Read(workBuffer.Buffer, 0, workBuffer.Capacity)
                            If bytesRead > 0 Then
                                workBuffer.ByteCount = bytesRead

                                ' COPY to INPUT monitor buffer (BEFORE processing - raw audio)
                                inputMonitorBuffer.Write(workBuffer.Buffer, 0, bytesRead)

                                ' Process through chain
                                Try
                                    processorChain.Process(workBuffer)
                                Catch
                                    ' Silently continue
                                End Try

                                ' Write to output buffer
                                Dim bytesWritten = outputBuffer.Write(workBuffer.Buffer, 0, workBuffer.ByteCount)

                                ' COPY to OUTPUT monitor buffer (AFTER processing - processed audio)
                                outputMonitorBuffer.Write(workBuffer.Buffer, 0, workBuffer.ByteCount)

                                ' Track stats
                                Interlocked.Add(_processedSamples, bytesRead \ Format.BlockAlign)

                                If bytesWritten < workBuffer.ByteCount Then
                                    Dim dropped = (workBuffer.ByteCount - bytesWritten) \ Format.BlockAlign
                                    Interlocked.Add(_droppedSamples, dropped)
                                End If
                                
                                cycleCount += 1
                                
                                ' Schedule next process time
                                nextProcessTime += targetTicksPerBlock
                            End If
                        Else
                            ' Not time yet - brief sleep
                            Thread.Sleep(1)
                        End If
                    Else
                        ' Not enough input - signal feeder
                        Dim inputFillPercent = (inputBuffer.Available * 100) \ inputBuffer.Capacity
                        If inputFillPercent < 50 Then
                            inputLowEvent.Set()
                        End If
                        
                        Thread.Sleep(1) ' Wait for more data
                    End If
                End While

            Catch ex As ThreadAbortException
                ' Exit cleanly
            Catch ex As Exception
                Utils.Logger.Instance.Error("DSP worker thread crashed", ex, "DSPThread")
            Finally
                _isRunning = False
                Utils.Logger.Instance.Info($"DSP worker stopped. Cycles={cycleCount}, Processed={ProcessedSamples}, Dropped={DroppedSamples}", "DSPThread")
            End Try
        End Sub

#End Region

#Region "IDisposable"

        Public Sub Dispose() Implements IDisposable.Dispose
            If Not disposed Then
                [Stop]()
                
                inputBuffer?.Dispose()
                outputBuffer?.Dispose()
                inputMonitorBuffer?.Dispose()
                outputMonitorBuffer?.Dispose()
                workBuffer?.Dispose()
                processorChain?.Dispose()
                inputLowEvent?.Dispose()

                Utils.Logger.Instance.Info($"DSP disposed. Processed: {ProcessedSamples}, Dropped: {DroppedSamples}", "DSPThread")
                disposed = True
            End If
        End Sub

#End Region

    End Class

End Namespace
