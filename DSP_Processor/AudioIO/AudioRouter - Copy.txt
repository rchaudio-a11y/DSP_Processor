Imports NAudio.Wave

Namespace AudioIO

    ''' <summary>
    ''' Simplified audio routing coordinator for Phase 2.0.
    ''' Manages input source selection and output device selection.
    ''' DSP integration added for pass-through testing.
    ''' </summary>
    Public Class AudioRouter
        Implements IDisposable

#Region "Enums"

        Public Enum InputSourceType
            Microphone
            FilePlayback
        End Enum

        Public Enum OutputDestinationType
            None = 0
            Speakers = 1
            File = 2
            Both = 3
        End Enum

#End Region

#Region "Private Fields"

        Private _currentInputSource As InputSourceType = InputSourceType.Microphone
        Private _currentOutputDestination As OutputDestinationType = OutputDestinationType.Speakers
        Private outputDeviceManager As OutputDeviceManager
        Private disposed As Boolean = False

        ' DSP Components
        Private dspThread As DSP.DSPThread
        Private dspOutputProvider As DSPOutputProvider
        Private waveOut As WaveOutEvent
        Private fileReader As AudioFileReader
        Private _selectedInputFile As String
        Private feederThread As System.Threading.Thread
        Private feederCancellation As Boolean = False ' Cancellation flag for feeder thread

#End Region

#Region "Properties"

        ''' <summary>Gets or sets the current input source</summary>
        Public Property CurrentInputSource As InputSourceType
            Get
                Return _currentInputSource
            End Get
            Set(value As InputSourceType)
                If value <> _currentInputSource Then
                    _currentInputSource = value
                    Utils.Logger.Instance.Info($"Input source changed to: {value}", "AudioRouter")
                    RaiseEvent InputSourceChanged(Me, value)
                End If
            End Set
        End Property

        ''' <summary>Gets or sets the current output destination</summary>
        Public Property CurrentOutputDestination As OutputDestinationType
            Get
                Return _currentOutputDestination
            End Get
            Set(value As OutputDestinationType)
                If value <> _currentOutputDestination Then
                    _currentOutputDestination = value
                    Utils.Logger.Instance.Info($"Output destination changed to: {value}", "AudioRouter")
                    RaiseEvent OutputDestinationChanged(Me, value)
                End If
            End Set
        End Property

        ''' <summary>Gets the output device manager</summary>
        Public ReadOnly Property OutputManager As OutputDeviceManager
            Get
                Return outputDeviceManager
            End Get
        End Property

        ''' <summary>Gets or sets the selected input file path</summary>
        Public Property SelectedInputFile As String
            Get
                Return _selectedInputFile
            End Get
            Set(value As String)
                _selectedInputFile = value
                Utils.Logger.Instance.Info($"Selected input file: {value}", "AudioRouter")
            End Set
        End Property

        ''' <summary>Is audio currently playing through DSP?</summary>
        Public ReadOnly Property IsPlaying As Boolean
            Get
                Return waveOut IsNot Nothing AndAlso waveOut.PlaybackState = PlaybackState.Playing
            End Get
        End Property

        ''' <summary>Gets the DSP thread for monitoring</summary>
        Public ReadOnly Property Thread As DSP.DSPThread
            Get
                Return dspThread
            End Get
        End Property

        ''' <summary>Gets the file reader wave format</summary>
        Public ReadOnly Property CurrentFormat As WaveFormat
            Get
                Return fileReader?.WaveFormat
            End Get
        End Property

#End Region

#Region "Events"

        Public Event InputSourceChanged As EventHandler(Of InputSourceType)
        Public Event OutputDestinationChanged As EventHandler(Of OutputDestinationType)
        Public Event PlaybackStopped As EventHandler

        ''' <summary>Raised when audio samples are available for FFT analysis (input)</summary>
        Public Event InputSamplesAvailable As EventHandler(Of AudioSamplesEventArgs)

        ''' <summary>Raised when audio samples are available for FFT analysis (output)</summary>
        Public Event OutputSamplesAvailable As EventHandler(Of AudioSamplesEventArgs)

#End Region

#Region "Initialization"

        ''' <summary>
        ''' Initializes the audio router
        ''' </summary>
        Public Sub Initialize()
            Try
                ' Create output device manager
                outputDeviceManager = New OutputDeviceManager()

                ' Select default output device
                Dim defaultDevice = outputDeviceManager.GetDefaultDeviceIndex()
                If defaultDevice >= 0 Then
                    outputDeviceManager.SelectedDeviceIndex = defaultDevice
                    Utils.Logger.Instance.Info($"Default output device: {defaultDevice}", "AudioRouter")
                End If

                Utils.Logger.Instance.Info("AudioRouter initialized (Phase 2.0 with DSP routing)", "AudioRouter")
            Catch ex As Exception
                Utils.Logger.Instance.Error("Failed to initialize AudioRouter", ex, "AudioRouter")
                Throw
            End Try
        End Sub

#End Region

#Region "Public Methods"

        ''' <summary>
        ''' Gets available output device names
        ''' </summary>
        Public Function GetOutputDeviceNames() As String()
            If outputDeviceManager IsNot Nothing Then
                Return outputDeviceManager.GetDeviceNames()
            End If
            Return Array.Empty(Of String)()
        End Function

        ''' <summary>
        ''' Selects an output device by index
        ''' </summary>
        ''' <param name="deviceIndex">Device index</param>
        Public Sub SelectOutputDevice(deviceIndex As Integer)
            Try
                If outputDeviceManager IsNot Nothing Then
                    outputDeviceManager.SelectedDeviceIndex = deviceIndex
                    Dim deviceNames = outputDeviceManager.GetDeviceNames()
                    If deviceIndex >= 0 AndAlso deviceIndex < deviceNames.Length Then
                        Utils.Logger.Instance.Info($"Output device selected: {deviceNames(deviceIndex)}", "AudioRouter")
                    End If
                End If
            Catch ex As Exception
                Utils.Logger.Instance.Error("Failed to select output device", ex, "AudioRouter")
                Throw
            End Try
        End Sub

        ''' <summary>
        ''' Gets the currently selected output device index
        ''' </summary>
        Public Function GetSelectedOutputDevice() As Integer
            If outputDeviceManager IsNot Nothing Then
                Return outputDeviceManager.SelectedDeviceIndex
            End If
            Return -1
        End Function

        ''' <summary>
        ''' Start playing audio through DSP chain (file input only for now)
        ''' </summary>
        Public Sub StartDSPPlayback()
            Try
                ' Stop any existing playback
                StopDSPPlayback()

                ' Validate we have a file selected
                If String.IsNullOrEmpty(_selectedInputFile) OrElse Not IO.File.Exists(_selectedInputFile) Then
                    Throw New InvalidOperationException("No valid input file selected")
                End If

                Utils.Logger.Instance.Info($"Starting DSP playback: {_selectedInputFile}", "AudioRouter")

                ' Create file reader (AudioFileReader provides IEEE Float)
                fileReader = New AudioFileReader(_selectedInputFile)
                Utils.Logger.Instance.Info($"File format: {fileReader.WaveFormat.SampleRate}Hz, {fileReader.WaveFormat.Channels}ch, IEEE Float (will convert to PCM16)", "AudioRouter")

                ' Create PCM16 wave format for DSP processing
                Dim pcm16Format As New WaveFormat(fileReader.WaveFormat.SampleRate, 16, fileReader.WaveFormat.Channels)

                Utils.Logger.Instance.Info("=== FORMAT CHAIN ===", "AudioRouter")
                Utils.Logger.Instance.Info($"FILE format: {fileReader.WaveFormat.SampleRate}Hz, {fileReader.WaveFormat.Channels}ch, {fileReader.WaveFormat.BitsPerSample}bit, Encoding={fileReader.WaveFormat.Encoding}, BlockAlign={fileReader.WaveFormat.BlockAlign}, AvgBytes/sec={fileReader.WaveFormat.AverageBytesPerSecond}", "AudioRouter")
                Utils.Logger.Instance.Info($"PCM16 format: {pcm16Format.SampleRate}Hz, {pcm16Format.Channels}ch, {pcm16Format.BitsPerSample}bit, Encoding={pcm16Format.Encoding}, BlockAlign={pcm16Format.BlockAlign}, AvgBytes/sec={pcm16Format.AverageBytesPerSecond}", "AudioRouter")

                ' Create DSP thread with 2-second ring buffers (proven stable size)
                ' 2 seconds provides ample buffering for 100ms WaveOut latency + processing overhead
                ' At 44.1kHz: 2 seconds = 88,200 samples per channel
                Dim inputBufferSize = pcm16Format.AverageBytesPerSecond * 2 ' 2 seconds of audio
                Dim outputBufferSize = pcm16Format.AverageBytesPerSecond * 2 ' 2 seconds of audio
                dspThread = New DSP.DSPThread(pcm16Format, inputBufferSize, outputBufferSize)

                Utils.Logger.Instance.Info($"DSP format: {dspThread.Format.SampleRate}Hz, {dspThread.Format.Channels}ch, {dspThread.Format.BitsPerSample}bit, Encoding={dspThread.Format.Encoding}, BlockAlign={dspThread.Format.BlockAlign}, AvgBytes/sec={dspThread.Format.AverageBytesPerSecond}", "AudioRouter")
                Utils.Logger.Instance.Info($"DSP buffers: {inputBufferSize} bytes input, {outputBufferSize} bytes output (2 seconds each)", "AudioRouter")

                ' Add gain processor (unity gain for now - adjustable later)
                Dim gainProcessor = New DSP.GainProcessor(pcm16Format) With {
                    .GainDB = 0.0F ' 0 dB = unity gain (no change)
                }
                dspThread.Chain.AddProcessor(gainProcessor)
                Utils.Logger.Instance.Info("Added Gain processor to chain (0 dB)", "AudioRouter")

                ' Create DSP output provider (bridges DSPThread to NAudio)
                dspOutputProvider = New DSPOutputProvider(dspThread)

                Utils.Logger.Instance.Info($"PROVIDER format: {dspOutputProvider.WaveFormat.SampleRate}Hz, {dspOutputProvider.WaveFormat.Channels}ch, {dspOutputProvider.WaveFormat.BitsPerSample}bit, Encoding={dspOutputProvider.WaveFormat.Encoding}, BlockAlign={dspOutputProvider.WaveFormat.BlockAlign}, AvgBytes/sec={dspOutputProvider.WaveFormat.AverageBytesPerSecond}", "AudioRouter")

                ' Create wave output with lower latency
                waveOut = New WaveOutEvent() With {
                    .DeviceNumber = outputDeviceManager.SelectedDeviceIndex,
                    .DesiredLatency = 100
                }

                Utils.Logger.Instance.Info($"WAVEOUT device: {outputDeviceManager.SelectedDeviceIndex}, DesiredLatency: 100ms", "AudioRouter")

                ' Wire up playback stopped event
                AddHandler waveOut.PlaybackStopped, AddressOf OnWaveOutStopped

                ' Initialize wave output with DSP provider
                waveOut.Init(dspOutputProvider)

                ' START DSP WORKER THREAD
                dspThread.Start()

                ' Pre-fill 1 second of audio data for smooth startup
                Dim prebufferSize = fileReader.WaveFormat.AverageBytesPerSecond * 1 ' 1 second in IEEE Float format
                Dim prebufferFloat(prebufferSize - 1) As Byte
                Dim bytesRead = fileReader.Read(prebufferFloat, 0, prebufferSize)

                If bytesRead > 0 Then
                    ' Convert pre-fill data to PCM16
                    Dim prebufferPCM16 = ConvertFloatToPCM16(prebufferFloat, bytesRead, fileReader.WaveFormat.Channels)

                    ' Write pre-fill to DSP input buffer
                    dspThread.WriteInput(prebufferPCM16, 0, prebufferPCM16.Length)

                    Utils.Logger.Instance.Info($"Pre-filled {prebufferPCM16.Length} bytes PCM16 (1 second)", "AudioRouter")
                End If

                ' Start feeding audio from file to DSP input
                StartFileFeeder()

                ' Brief delay to let DSP worker fill output buffer
                System.Threading.Thread.Sleep(100)

                ' Start playback
                waveOut.Play()

                Utils.Logger.Instance.Info("DSP playback started successfully", "AudioRouter")

            Catch ex As Exception
                Utils.Logger.Instance.Error("Failed to start DSP playback", ex, "AudioRouter")
                StopDSPPlayback() ' Cleanup on error
                Throw
            End Try
        End Sub

        ''' <summary>
        ''' Background thread that feeds audio from file to DSP input buffer (EVENT-DRIVEN)
        ''' Waits for signal from DSP when input buffer is low (<25%)
        ''' </summary>
        Private Sub StartFileFeeder()
            feederCancellation = False ' Reset cancellation flag

            ' Capture format and signal event for use in thread
            Dim inputFormat = fileReader.WaveFormat
            Dim pcm16BlockAlign = inputFormat.Channels * 2 ' 2 bytes per PCM16 sample
            Dim inputLowSignal = dspThread.InputLowSignal

            feederThread = New System.Threading.Thread(
                Sub()
                    Try
                        ' Industry standard block size: 256 samples
                        Const BLOCK_SIZE_SAMPLES As Integer = 256

                        Dim floatBlockSize = BLOCK_SIZE_SAMPLES * inputFormat.Channels * 4 ' 4 bytes per float
                        Dim pcm16BlockSize = BLOCK_SIZE_SAMPLES * pcm16BlockAlign
                        Dim floatBuffer(floatBlockSize - 1) As Byte
                        Dim bytesRead As Integer
                        Dim blockCount As Integer = 0
                        Dim signalCount As Integer = 0
                        Dim timeoutCount As Integer = 0

                        Utils.Logger.Instance.Info($"File feeder started (EVENT-DRIVEN): {BLOCK_SIZE_SAMPLES} samples per block ({floatBlockSize} bytes IEEE Float → {pcm16BlockSize} bytes PCM16)", "AudioRouter")

                        While Not feederCancellation
                            ' WAIT for signal from DSP (input buffer <25%)
                            ' Use 100ms timeout to check cancellation periodically
                            If Not inputLowSignal.WaitOne(100) Then
                                timeoutCount += 1
                                Continue While ' Timeout - check cancellation and wait again
                            End If

                            signalCount += 1

                            ' Check cancellation after waking
                            If feederCancellation Then Exit While

                            ' Read from file
                            bytesRead = fileReader.Read(floatBuffer, 0, floatBlockSize)
                            If bytesRead = 0 Then
                                Utils.Logger.Instance.Info("File feeder reached end of file", "AudioRouter")
                                Exit While
                            End If

                            ' Convert to PCM16
                            Dim pcm16Buffer = ConvertFloatToPCM16(floatBuffer, bytesRead, inputFormat.Channels)

                            ' Write to input buffer (should succeed since DSP signaled us)
                            Dim bytesWritten = dspThread.WriteInput(pcm16Buffer, 0, pcm16Buffer.Length)

                            If bytesWritten < pcm16Buffer.Length Then
                                ' Shouldn't happen since DSP signaled low buffer, but handle it
                                Utils.Logger.Instance.Warning($"Feeder couldn't write full block: wrote {bytesWritten}/{pcm16Buffer.Length}", "AudioRouter")
                            End If

                            blockCount += 1

                            ' Log every 50 blocks
                            If blockCount Mod 50 = 0 Then
                                Utils.Logger.Instance.Info($"FEEDER: Block #{blockCount}, Signals={signalCount}, Timeouts={timeoutCount}", "AudioRouter")
                            End If
                        End While

                        Utils.Logger.Instance.Info($"File feeder stopped: {blockCount} blocks written, {signalCount} signals received, {timeoutCount} timeouts", "AudioRouter")

                    Catch ex As System.Threading.ThreadAbortException
                        Utils.Logger.Instance.Info("File feeder thread aborted", "AudioRouter")
                    Catch ex As Exception
                        Utils.Logger.Instance.Error("File feeder error", ex, "AudioRouter")
                    End Try
                End Sub
            )

            feederThread.Name = "File Feeder Thread (Event-Driven)"
            feederThread.Priority = System.Threading.ThreadPriority.AboveNormal ' Higher priority
            feederThread.IsBackground = True
            feederThread.Start()
        End Sub

        ''' <summary>
        ''' Convert IEEE Float samples (AudioFileReader format) to 16-bit PCM
        ''' </summary>
        Private Function ConvertFloatToPCM16(floatBuffer As Byte(), byteCount As Integer, channels As Integer) As Byte()
            ' AudioFileReader provides IEEE Float (32-bit per sample)
            Dim sampleCount = byteCount \ 4 ' 4 bytes per float sample
            Dim pcm16Buffer(sampleCount * 2 - 1) As Byte ' 2 bytes per 16-bit sample

            ' Log first conversion for verification
            Static firstLog As Boolean = True
            If firstLog Then
                Utils.Logger.Instance.Info($"Float→PCM16: {byteCount} bytes float → {sampleCount} samples → {pcm16Buffer.Length} bytes PCM16", "AudioRouter")
                firstLog = False
            End If

            For i = 0 To sampleCount - 1
                ' Read float sample (-1.0 to +1.0)
                Dim floatSample = BitConverter.ToSingle(floatBuffer, i * 4)

                ' Clamp to valid range
                floatSample = Math.Max(-1.0F, Math.Min(1.0F, floatSample))

                ' Convert to 16-bit integer (-32768 to 32767)
                Dim int16Sample = CShort(floatSample * 32767.0F)

                ' Write as little-endian bytes
                pcm16Buffer(i * 2) = CByte(int16Sample And &HFF)
                pcm16Buffer(i * 2 + 1) = CByte((int16Sample >> 8) And &HFF)
            Next

            Return pcm16Buffer
        End Function

        ''' <summary>
        ''' Stop DSP playback
        ''' </summary>
        Public Sub StopDSPPlayback()
            Try
                Utils.Logger.Instance.Info("Stopping DSP playback", "AudioRouter")

                ' Signal feeder thread to stop FIRST
                feederCancellation = True

                ' Stop wave output (this stops pulling from DSP output)
                If waveOut IsNot Nothing Then
                    RemoveHandler waveOut.PlaybackStopped, AddressOf OnWaveOutStopped
                    waveOut.Stop()
                    waveOut.Dispose()
                    waveOut = Nothing
                End If

                ' Wait for feeder thread to exit gracefully (short timeout)
                If feederThread IsNot Nothing AndAlso feederThread.IsAlive Then
                    If Not feederThread.Join(200) Then ' Wait max 200ms
                        Utils.Logger.Instance.Warning("File feeder thread did not exit gracefully", "AudioRouter")
                    End If
                    feederThread = Nothing
                End If

                ' Stop DSP worker thread
                If dspThread IsNot Nothing Then
                    dspThread.Stop()
                    dspThread.Dispose()
                    dspThread = Nothing
                End If

                ' Dispose output provider
                dspOutputProvider = Nothing

                ' Dispose file reader (this will unblock any pending Read() calls)
                If fileReader IsNot Nothing Then
                    fileReader.Dispose()
                    fileReader = Nothing
                End If

                Utils.Logger.Instance.Info("DSP playback stopped successfully", "AudioRouter")

            Catch ex As Exception
                Utils.Logger.Instance.Error("Error stopping DSP playback", ex, "AudioRouter")
            End Try
        End Sub

#End Region

#Region "Private Methods"

        Private Sub OnWaveOutStopped(sender As Object, e As NAudio.Wave.StoppedEventArgs)
            Utils.Logger.Instance.Info("WaveOut playback stopped", "AudioRouter")
            StopDSPPlayback()
            RaiseEvent PlaybackStopped(Me, EventArgs.Empty)
        End Sub

        ''' <summary>
        ''' Raise input samples event for FFT analysis (non-blocking)
        ''' </summary>
        Private Sub RaiseInputSamplesEvent(buffer As Byte(), count As Integer, bitsPerSample As Integer)
            ' NOT USED - We pull FFT from DSP output buffer instead
            ' This method kept for future reference if we need pre-DSP monitoring
        End Sub

        ''' <summary>
        ''' Get output samples from DSP for FFT analysis (non-blocking)
        ''' Feeds BOTH input and output FFT displays with processed audio
        ''' </summary>
        Public Sub UpdateOutputSamples()
            Try
                If dspThread IsNot Nothing Then
                    ' Check if output buffer has data
                    Dim available = dspThread.OutputAvailable()

                    ' Read up to 8KB for FFT (don't need full 4096 samples every time)
                    ' This allows FFT to update more frequently
                    If available > 0 Then
                        Dim bufferSize = Math.Min(available, 8192) ' Read up to 8KB
                        Dim buffer(bufferSize - 1) As Byte
                        Dim bytesRead = dspThread.ReadOutput(buffer, 0, buffer.Length)

                        If bytesRead > 0 AndAlso fileReader IsNot Nothing Then
                            ' Clone the buffer so we don't block the caller
                            Dim clonedBuffer(bytesRead - 1) As Byte
                            Array.Copy(buffer, clonedBuffer, bytesRead)

                            Dim args As New AudioSamplesEventArgs With {
                                .Samples = clonedBuffer,
                                .Count = bytesRead,
                                .SampleRate = fileReader.WaveFormat.SampleRate,
                                .Channels = fileReader.WaveFormat.Channels,
                                .BitsPerSample = 16
                            }

                            ' Raise event asynchronously (don't block caller)
                            System.Threading.ThreadPool.QueueUserWorkItem(
                                Sub(state)
                                    Try
                                        RaiseEvent OutputSamplesAvailable(Me, args)
                                    Catch ex As Exception
                                        ' Ignore FFT errors
                                        Utils.Logger.Instance.Debug($"Output FFT error: {ex.Message}", "AudioRouter")
                                    End Try
                                End Sub
                            )
                        End If
                    End If
                End If
            Catch ex As Exception
                ' Don't let FFT errors crash the update
                Utils.Logger.Instance.Debug($"Output samples event error: {ex.Message}", "AudioRouter")
            End Try
        End Sub

#End Region

#Region "IDisposable"

        Public Sub Dispose() Implements IDisposable.Dispose
            If Not disposed Then
                Utils.Logger.Instance.Info("Disposing AudioRouter", "AudioRouter")
                StopDSPPlayback()
                disposed = True
            End If
        End Sub

#End Region

    End Class

    ''' <summary>Event args for audio samples (FFT analysis)</summary>
    Public Class AudioSamplesEventArgs
        Inherits EventArgs

        Public Property Samples As Byte()
        Public Property Count As Integer
        Public Property SampleRate As Integer
        Public Property Channels As Integer
        Public Property BitsPerSample As Integer
    End Class

End Namespace
